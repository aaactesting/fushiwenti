## 数组和链表的区别
- 数组地址空间连续,链表不连续
- 查询方面,数组随机查询比链表快
- 插入和删除方面,链表优于数组

## 堆和堆栈(就是栈)的区别
- 内存管理方面，栈由操作系统分配和释放内存，无需手动操作，而堆需要程序员去手动管理
- 空间大小不同，堆的空间大小远大于栈
- 堆一般存放的是new出来那些对象或数组，而栈一般存放的是局部变量，引用等
- 堆只有动态分配，而栈有动态分配和静态分配


## 度为2的树和二叉树的区别
- 度为2的树没有左右次序之分,二叉树分为左孩子和右孩子之分
- 度为2的树度只能为2和0,二叉树度可以为2,1,0

## 排序算法有哪些?(把那个表看熟,一般问到这个先说有哪些,老师可能会要你详细说两三种排序算法)
- 插入排序:思想是把每个元素往前移动到比它小的那个元素前面(最好为O(n)，其他为n^2)
- 选择排序:思想是每次选择元素最小或最大的那个元素,移动到首部或者尾部
- 冒泡排序:每次选择两个相邻元素,比较大小,不符合则交换他们。(最好为O(n)，其他为n^2)
- 快速排序:优点 速度很快,但是不利于在数据有序的情况,时间复杂度最快为O(n^2)
- 希尔排序:
- 基数排序:
- 归并排序: 空间复杂度为O(n)
- 堆排序:空间复杂度为O(1)

## 快速排序的改进
- 当划分到较小的子数组时，通常可以使用插入排序替代快速排序
- 基准值的选取，我们随机取出来3个数，取中间大小的为基准值。

## 图有哪些存储结构？
- 邻接矩阵:以二维数组的方式
- 邻接表:使用一维链表数组存储
- 邻接多重表: 

## 克鲁斯卡尔算法和普里姆算法的时间复杂度是多少
- 克鲁斯卡尔算法时间复杂度为O(e*loge)
- 普里姆算法时间复杂度为O(n^2)

## 简述快速排序的过程
- 首先,右指针指向最后一个元素,左指针指向第一个
- 然后,右指针往左边移选择元素最小的那个,左指针往右边移动选择元素最大的那个,交换两边元素以及基准元素
- 最后,在基准两边进行划分,对两边再次进行快排递归,直到左指针==右指针,就结束


## 循环和递归的区别
- 循环在一般情况下效率都是比递归高的,这是因为递归需要栈来进行递归处理
- 循环无法解决一些比较特殊的问题,只能用递归

## 解决哈希冲突的方法有哪些
- 开放地址法:当冲突时,使用哈希函数产生一个地址来存放
- 链地址法:使用链表数组来解决冲突,冲突时,插入结点到头部
- 双重散列法: ....

## B树和B+树的区别
- B+树存储的是索引信息,B树存储的是数据关键字
- B+树数据存储在树的叶子节点,B树数据存在树的每个结点
- B+树分支节点有m个关键字,叶子节点也有m个,B树则存在k-1个关键字
- B+树叶子节点从左到右有序,并且用链表形式结合起来

## 贪心算法,动态规划,分治的区别
- 贪心算法的思想是每一步作出最优的决策,来达到最终问题的最优解,比如克露斯卡尔采用的就是贪心算法的思想,每次选取最短的那条边
- 动态规划是把一个问题划分为多个子问题,然后利用这些子问题的最优解来得出问题的最优解
- 分支算法和动态规划差不多,也是把一个问题划分为多个子问题,不同的是,这些子问题都是相对独立的,通过递归来实现

## 如何去判断链表存在环?
- 第一种思路:使用HashMap,每次遍历把链表节点指针地址放到hashmap的key,一旦产生哈希冲突,直接断定链表有环,出口return false
- 第二种思路:使用快慢指针,快指针每次走两步,慢的走一步,一旦快指针追上慢指针的时候,可以断定有环
- 第二种思路是最好的,空间复杂度为O(1),第一种思路需要O(n)空间,效率也更高

## 如何去判断一颗二叉树是平衡二叉树?
- 对树上每个结点进行左右子树高度的判断,一旦左子树和右子树的差大于1,就是不平衡的。代码描述的话,需要使用两次深度优先搜索,一个用来遍历二叉树所有节点,一个用来求二叉树的高度


